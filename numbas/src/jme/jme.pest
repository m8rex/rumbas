WHITESPACE = _{ " " | "\t" | newline }
COMMENT    = _{ block_comment | ("//" ~ (!newline ~ ANY)*) }
newline    = _{ "\n" | "\r\n" }
block_comment = _{ "/*" ~ (block_comment | !"*/" ~ ANY)* ~ "*/" }

jme = {
    SOI
    ~ expression
    ~ EOI
}

embraced_jme = { SOI ~ (normal_char | (brace_open ~ expression ~ brace_close))* ~ EOI  }
brace_open = _{ !"\\{" ~ "{" }
brace_close = _{ !"\\}" ~ "}" }
normal_char = _{ "\\{" | "\\}" | (!(brace_open | brace_close) ~ ANY) }

expression =  { term ~ (infix_operator ~ term)* }
term       =  { prefix_operator* ~ node ~ postfix_operator* }
node       = _{ grouped_expression | terminal } 
terminal = _{ function_application | ident | collection | literal }  
grouped_expression = _{ "(" ~ expression ~ ")" }

reserved = @{ (boolean | constant_name | logic_binary_operator | not_operator | in_operator | except | isa| cast_operator ) ~ !ident_char_all }

literal = _{ boolean | number | string | constant }

constant_name = { infinity_constant | nan_constant | changeable_constant }
infinity_constant = { "infty" | "infinity" | "∞" }
nan_constant = { "nan" }
changeable_constant = { e_constant | pi_constant | i_constant }
e_constant = { "e" }
i_constant = { "i" }
pi_constant = { "pi" | "π" }
constant = { (annotation)* ~ constant_name }

number = _{ broken_number | integer }
integer = { ASCII_NONZERO_DIGIT ~ ASCII_DIGIT* | "0" }
broken_part = { ASCII_DIGIT* }
broken_number = { integer ~ !".." ~ "." ~ broken_part }
boolean = { boolean_true | boolean_false }
boolean_true = { "true" }
boolean_false = { "false" }
string = { PUSH("\"" | "'") ~ inner_str ~ POP }

inner_str = @{ (!(PEEK | "\\") ~ ANY)* ~ (escape ~ inner_str)? }
escape    = @{ "\\" ~ (PEEK | "\\" | "n" | "t" ) } 

function_arguments = { expression ~ ("," ~ expression)* }
function_application = { ident ~ "(" ~ function_arguments ~ ")" }

implicit_multiplication_operator = { "" }

verb_annotation = { "verb:" }
op_annotation = { "op:" }
vector_annotation = { "vector:" | "v:" }
unit_annotation = { "unit:" }
dot_annotation = { "dot:" }
matrix_annotation = { "matrix:" | "m:" }
diff_annotation = { "diff:" }
degrees_annotation = { "degrees:" }
builtin_annotation = { verb_annotation | op_annotation | vector_annotation | unit_annotation | dot_annotation | matrix_annotation | diff_annotation | degrees_annotation }
other_annotation = { ASCII_ALPHA+ ~ ":" }
annotation = { (builtin_annotation | other_annotation) }
ident_char_all = _{ ident_char | "'" }
ident_char = _{ CASED_LETTER | ASCII_DIGIT | "_"  }
ident_name = @{ !reserved ~ CASED_LETTER ~ ident_char* ~ "'"* }
ident = { (annotation)* ~ ident_name }


collection = _{ dictionary | list }
dictionary = { "[" ~ dictionary_item ~ ("," ~ dictionary_item )* ~ "]" }
dictionary_key = _{ ident_name | string }
dictionary_item = { dictionary_key ~ ":" ~ expression }
list = { "[" ~ (expression ~ ("," ~ expression )*)? ~ "]" }

arithmetic_operator = _{ add | subtract | multiply | divide | power }
    add      = { "+" }
    subtract = { "-" }
    multiply = { "*" }
    divide   = { "/" }
    power    = { "^" }
    except   = { "except" }
relational_operator = { less_or_equal | not_equal | less | greater_or_equal | greater | equal | in_operator | divides_operator | isa } 
    less_or_equal = _{ "<="  } 
    not_equal = _{ "<>" } 
    less = _{  "<" } 
    greater_or_equal = _{ ">=" } 
    greater = _{ ">" } 
    equal = _{ "=" } 
    isa = _{ "isa" } 
    in_operator = _{ "in" } 
    divides_operator = _{ "|" } 
and_operator = _{ "and" | "&&" | "&" }
or_operator = _{ "or" }
xor_operator = _{ "xor" }
implies_operator = _{ "implies" }
logic_binary_operator = { and_operator | or_operator | xor_operator | implies_operator }
cast_operator = { "as" }
infix_operator = _{ arithmetic_operator | cast_operator | relational_operator | logic_binary_operator | range_separator | range_step_separator | implicit_multiplication_operator }
range_separator = { ".." }
range_step_separator = { "#" }
index_operator = { "[" ~ (string | integer | ident_name) ~ "]" } 
faculty_operator =  { "!" }
postfix_operator = _{ faculty_operator | index_operator }
not_operator = _{ "!" | "not" }
unary_minus = _{ "-" }
prefix_operator = { not_operator | unary_minus }

// HTML (based on https://gist.github.com/mathiversen/69d744da9d80bf774ed549511e12d884)
//
html = _{
    SOI
    ~ html_node_comment*
    ~ html_doctype?
    ~ html_node*
    ~ EOI
}
content_area = {
    SOI
    ~ html_node_comment*
    ~ html_doctype?
    ~ html_node*
    ~ EOI
}

//
// DOCTYPE
//
html_doctype_name = _{ "doctype" | "DOCTYPE" }
html_doctype = _{ html_chevron_left_bang ~ html_doctype_name ~ html_attr* ~ html_chevron_right}

//
// NODES
//
html_node = _{ html_node_comment | html_node_element | html_latex | html_embraced_jme }
html_node_comment = _{ html_comment_tag_start ~ (!html_comment_tag_end ~ ANY)* ~ html_comment_tag_end }
//html_node_text = { (!(html_chevron_left | html_comment_tag_start ) ~ ANY }
html_node_element = _{ html_el_void | html_el_void_xml | html_el_process_instruct | html_el_raw_text | html_el_normal | html_el_dangling }

html_latex = _{ "$" ~ (!"$" ~ latex_content)*  ~ "$" }
latex_jme_expression_start = _{ ("\\var" | "\\simplify") ~ brace_open }
latex_content = _{ (latex_jme_expression_start ~ expression ~ brace_close) | (!latex_jme_expression_start ~ ANY) }
html_embraced_jme = _{ ( !(html_chevron_left | html_comment_tag_start | "$") ~ (normal_char | (brace_open ~ expression ~ brace_close)) )+ }

//
// COMMENTS
//
html_comment_tag_start = @{ html_chevron_left_bang ~ "--" }
html_comment_tag_end = @{ "--" ~ html_chevron_right }

//
// ATTRIBUTES
//
html_attr_key = _{ ASCII_ALPHA ~ html_text_chars* }
html_attr_value = _{ (!PEEK ~ ANY)* }
html_attr_quoted =  _{PUSH(html_quote) ~ html_attr_value ~ POP }
html_attr_non_quoted = _{ (!WHITESPACE ~ ANY)* }
html_attr = _{ html_attr_key ~ (html_equal ~ (html_attr_quoted | html_attr_non_quoted))? }

//
// ELEMENTS
//
html_el_name = @{ ASCII_ALPHA ~ html_text_chars* }

// Void element aka self-closing element
// Ex: <hr>
html_el_void_name_html = @{
    "area"
    | "base"
    | "br"
    | "col"
    | "command"
    | "embed"
    | "hr"
    | "img"
    | "input"
    | "keygen"
    | "link"
    | "meta"
    | "param"
    | "source"
    | "track"
    | "wbr"
    | "meta"
}
// NOTE: This should not have to be a rule, but people doesn't know what void elements are...
html_el_void_name_svg = @{
    "path"
    | "polygon"
    | "rect"
    | "circle"
}
html_el_void_name = @{ html_el_void_name_html | html_el_void_name_svg }
html_el_void = _{ html_chevron_left ~ html_el_void_name ~ html_attr* ~ (html_chevron_right | html_chevron_right_closed) }
html_el_void_xml = _{ html_chevron_left ~ html_el_name ~ html_attr* ~ html_chevron_right_closed }

// Open elements are default element that can take children 
// and have both a start tag and an end tag
// Ex: <html lang="en"></html>
html_el_normal = _{ html_el_normal_start ~ (!html_el_normal_end ~ html_node)* ~ html_el_normal_end }
html_el_normal_start = _{ html_chevron_left ~ PUSH(html_el_name) ~ html_attr* ~ html_chevron_right}
html_el_normal_end = _{ html_chevron_left_closed ~ POP ~ html_chevron_right}

// Raw text elements are elements with text/script content that
// might interfere with the normal html syntax
html_el_raw_text_name = _{ "style" | "script" }
html_el_raw_text = _{ html_el_raw_text_start ~ (!html_el_raw_text_end ~ ANY)* ~ html_el_raw_text_end }
html_el_raw_text_start = _{ html_chevron_left ~ PUSH(html_el_raw_text_name) ~ html_attr* ~ html_chevron_right}
html_el_raw_text_end = _{ html_chevron_left_closed ~ POP ~ html_chevron_right}

// XML processing instruction
// Ex: <?xml version="1.0" ?>
html_el_process_instruct = _{ html_chevron_left_question ~ "xml" ~ html_attr* ~ html_chevron_right_question }

// Catch dangling elements
// Ex: <div/></div>
html_el_dangling = _{ html_chevron_left_closed ~ html_el_name ~ html_chevron_right}

//
// SYMBOLS / CHARACTERS
//
html_text_chars = _{'a'..'z' | 'A'..'Z' | "_" | "-" | ":" |'0'..'9'}

html_chevron_left = _{ "<" }
html_chevron_left_closed = _{ "</" }
html_chevron_left_bang = _{ "<!" }
html_chevron_left_question = _{ "<?" }

html_chevron_right = _{ ">" }
html_chevron_right_closed = _{ "/>" }
html_chevron_right_question = _{ "?>" }

html_equal = _{ "=" }
html_quote_dubble = _{ "\"" }
html_quote_single = _{ "'" }
html_quote = _{ html_quote_dubble | html_quote_single }

