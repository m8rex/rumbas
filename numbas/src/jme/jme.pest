jme = {
    SOI
    ~ expression
    ~ EOI
}
WHITESPACE = _{ (" " | "\t" | "\r" | "\n")+ }

expression =  { term ~ (infix_operator ~ term)* }
term       =  { prefix_operator* ~ node ~ postfix_operator* }
node       = _{ implicit_multiplication | grouped_expression | terminal }
terminal = _{ function_application | ident | collection | literal }  
grouped_expression = { "(" ~ expression ~ ")" }

// reserved = { e_constant | i_constant | pi_constant | nan_constant | infinity_constant | boolean }

literal = _{ boolean | number | string }
//constant = { infinity_constant | nan_constant | changeable_constant }
// TODO: to rust code side
//infinity_constant = { "infty" | "infinity" }
// TODO unicode infinity char
//nan_constant = { "nan" }
//changeable_constant = { e_constant | pi_constant | i_constant }
//e_constant = { "e" }
//i_constant = { "i" }
//pi_constant = { "pi" }
// TODO pi unicode

number = _{ broken_number | integer }
integer = { ("-")? ~ ASCII_NONZERO_DIGIT ~ ASCII_DIGIT* | "0" }
broken_part = { ASCII_DIGIT* }
broken_number = { integer ~ "." ~ broken_part }
boolean = { boolean_true | boolean_false }
boolean_true = { "true" }
boolean_false = { "false" }
string = { "\"" ~ non_double_quoted_character* ~ "\"" }
non_double_quoted_character = _{ !"\"" ~ ANY }
non_single_quoted_character = _{ !"'" ~ ANY }


//arithmetic_function = { "exp" }
//builtin_function = { arithmetic_function }
//function = { builtin_function | ident }
//annotated_function = { (annotation)* ~ function }
function_arguments = { expression ~ ("," ~ expression)* }
function_application = { ident ~ "(" ~ function_arguments ~ ")" }

implicit_multiplication = { 
	(grouped_expression ~ ( ident | number | grouped_expression)) |
	( (number | ident) ~ ident)
} // TODO x y z etc

//annotated_variable = { (annotation)* ~ ident }
verb_annotation = { "verb:" }
op_annotation = { "op:" }
vector_annotation = { "vector:" | "v:" }
unit_annotation = { "unit:" }
dot_annotation = { "dot:" }
matrix_annotation = { "matrix:" | "m:" }
diff_annotation = { "diff:" }
degrees_annotation = { "degrees:" }
builtin_annotation = { verb_annotation | op_annotation | vector_annotation | unit_annotation | dot_annotation | matrix_annotation | diff_annotation | degrees_annotation }
other_annotation = { ASCII_ALPHA+ ~ ":" }
annotation = { (builtin_annotation | other_annotation) }
// TODO: other
ident_name = _{ ASCII_ALPHA ~ (ASCII_ALPHA | ASCII_DIGIT | "_")* ~ "'"* }
ident = { (annotation)* ~ ident_name }


collection = _{ dictionary | list }
dictionary = { "[" ~ dictionary_item ~ ("," ~ dictionary_item )* ~ "]" }
dictionary_key = { ident_name | string }
dictionary_item = { dictionary_key ~ ":" ~ expression }
list = { "[" ~ (expression ~ ("," ~ expression )*)? ~ "]" }

arithmetic_operator = _{ add | subtract | multiply | divide | power }
    add      = { "+" }
    subtract = { "-" }
    multiply = { "*" }
    divide   = { "/" }
    power    = { "^" }
relational_operator = { less_or_equal | not_equal | less | greater_or_equal | greater | equal | in_operator } 
    less_or_equal = { "<="  } 
    not_equal = { "<>" } 
    less = {  "<" } 
    greater_or_equal = { ">=" } 
    greater = { ">" } 
    equal = { "=" } 
    in_operator = { "in" } 
and_operator = { "and" | "&&" | "&" }
or_operator = { "or" }
xor_operator = { "xor" }
implies_operator = { "implies" }
logic_binary_operator = { relational_operator | and_operator | or_operator | xor_operator | implies_operator }
infix_operator = _{ arithmetic_operator | logic_binary_operator }
range = { integer? ~ ".." ~ integer? }  
index_operator = { "[" ~ (string | range | integer | ident_name) ~ "]" } 
faculty_operator =  { "!" }
postfix_operator = _{ faculty_operator | index_operator }
not_operator = { "!" | "not" }
prefix_operator = _{ not_operator }
