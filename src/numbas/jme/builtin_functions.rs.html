<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `numbas/src/jme/builtin_functions.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>builtin_functions.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../../normalize.css"><link rel="stylesheet" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../../ayu.css" disabled><link rel="stylesheet" href="../../../dark.css" disabled><link rel="stylesheet" href="../../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../../storage.js"></script><script defer src="../../../source-script.js"></script><script defer src="../../../source-files.js"></script><script defer src="../../../main.js"></script><noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"></nav><main><div class="width-limiter"><nav class="sub"><a class="sub-logo-container" href="../../../numbas/index.html"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></a><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><a href="../../../help.html">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../wheel.svg"></a></div></div></form></nav><section id="main-content" class="content"><div class="example-wrap"><pre class="src-line-numbers"><span id="1">1</span>
<span id="2">2</span>
<span id="3">3</span>
<span id="4">4</span>
<span id="5">5</span>
<span id="6">6</span>
<span id="7">7</span>
<span id="8">8</span>
<span id="9">9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
<span id="44">44</span>
<span id="45">45</span>
<span id="46">46</span>
<span id="47">47</span>
<span id="48">48</span>
<span id="49">49</span>
<span id="50">50</span>
<span id="51">51</span>
<span id="52">52</span>
<span id="53">53</span>
<span id="54">54</span>
<span id="55">55</span>
<span id="56">56</span>
<span id="57">57</span>
<span id="58">58</span>
<span id="59">59</span>
<span id="60">60</span>
<span id="61">61</span>
<span id="62">62</span>
<span id="63">63</span>
<span id="64">64</span>
<span id="65">65</span>
<span id="66">66</span>
<span id="67">67</span>
<span id="68">68</span>
<span id="69">69</span>
<span id="70">70</span>
<span id="71">71</span>
<span id="72">72</span>
<span id="73">73</span>
<span id="74">74</span>
<span id="75">75</span>
<span id="76">76</span>
<span id="77">77</span>
<span id="78">78</span>
<span id="79">79</span>
<span id="80">80</span>
<span id="81">81</span>
<span id="82">82</span>
<span id="83">83</span>
<span id="84">84</span>
<span id="85">85</span>
<span id="86">86</span>
<span id="87">87</span>
<span id="88">88</span>
<span id="89">89</span>
<span id="90">90</span>
<span id="91">91</span>
<span id="92">92</span>
<span id="93">93</span>
<span id="94">94</span>
<span id="95">95</span>
<span id="96">96</span>
<span id="97">97</span>
<span id="98">98</span>
<span id="99">99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
<span id="465">465</span>
<span id="466">466</span>
<span id="467">467</span>
<span id="468">468</span>
<span id="469">469</span>
<span id="470">470</span>
<span id="471">471</span>
<span id="472">472</span>
<span id="473">473</span>
<span id="474">474</span>
<span id="475">475</span>
<span id="476">476</span>
<span id="477">477</span>
<span id="478">478</span>
<span id="479">479</span>
<span id="480">480</span>
<span id="481">481</span>
<span id="482">482</span>
<span id="483">483</span>
<span id="484">484</span>
<span id="485">485</span>
<span id="486">486</span>
<span id="487">487</span>
<span id="488">488</span>
<span id="489">489</span>
<span id="490">490</span>
<span id="491">491</span>
<span id="492">492</span>
<span id="493">493</span>
<span id="494">494</span>
<span id="495">495</span>
<span id="496">496</span>
<span id="497">497</span>
<span id="498">498</span>
<span id="499">499</span>
<span id="500">500</span>
<span id="501">501</span>
<span id="502">502</span>
<span id="503">503</span>
<span id="504">504</span>
<span id="505">505</span>
<span id="506">506</span>
<span id="507">507</span>
<span id="508">508</span>
<span id="509">509</span>
<span id="510">510</span>
<span id="511">511</span>
<span id="512">512</span>
<span id="513">513</span>
<span id="514">514</span>
<span id="515">515</span>
<span id="516">516</span>
<span id="517">517</span>
<span id="518">518</span>
<span id="519">519</span>
<span id="520">520</span>
<span id="521">521</span>
<span id="522">522</span>
<span id="523">523</span>
<span id="524">524</span>
<span id="525">525</span>
<span id="526">526</span>
<span id="527">527</span>
<span id="528">528</span>
<span id="529">529</span>
<span id="530">530</span>
<span id="531">531</span>
<span id="532">532</span>
<span id="533">533</span>
<span id="534">534</span>
<span id="535">535</span>
<span id="536">536</span>
<span id="537">537</span>
<span id="538">538</span>
<span id="539">539</span>
<span id="540">540</span>
<span id="541">541</span>
<span id="542">542</span>
<span id="543">543</span>
<span id="544">544</span>
<span id="545">545</span>
<span id="546">546</span>
<span id="547">547</span>
<span id="548">548</span>
<span id="549">549</span>
<span id="550">550</span>
<span id="551">551</span>
<span id="552">552</span>
<span id="553">553</span>
<span id="554">554</span>
<span id="555">555</span>
<span id="556">556</span>
<span id="557">557</span>
<span id="558">558</span>
<span id="559">559</span>
<span id="560">560</span>
<span id="561">561</span>
<span id="562">562</span>
<span id="563">563</span>
<span id="564">564</span>
<span id="565">565</span>
<span id="566">566</span>
<span id="567">567</span>
<span id="568">568</span>
<span id="569">569</span>
<span id="570">570</span>
<span id="571">571</span>
<span id="572">572</span>
<span id="573">573</span>
<span id="574">574</span>
<span id="575">575</span>
<span id="576">576</span>
<span id="577">577</span>
<span id="578">578</span>
<span id="579">579</span>
<span id="580">580</span>
<span id="581">581</span>
<span id="582">582</span>
<span id="583">583</span>
<span id="584">584</span>
</pre><pre class="rust"><code><span class="kw">use </span>serde::{Deserialize, Serialize};

<span class="attribute">#[derive(Clone, Debug, Eq, PartialEq, Deserialize, Serialize)]
#[serde(rename_all = <span class="string">&quot;lowercase&quot;</span>)]
</span><span class="kw">pub enum </span>BuiltinFunctions {
    <span class="doccomment">/// Synonym of e^x
    </span>Exp,

    <span class="doccomment">/// Construct a decimal value. Any string accepted by Decimal.js is accepted.
    </span><span class="attribute">#[serde(alias = <span class="string">&quot;dec&quot;</span>)]
    </span>Decimal,
    <span class="doccomment">/// Convert n to a rational nubmer, taking an approximation when necessary.
    </span>Rational,
    <span class="doccomment">/// Convert n to an integer, rounding to the nearest integer.
    </span>Int,
    <span class="attribute">#[serde(alias = <span class="string">&quot;len&quot;</span>)]
    #[serde(alias = <span class="string">&quot;length&quot;</span>)]
    </span><span class="doccomment">/// Absolute value, or modulus.
    </span>Abs, <span class="comment">// TODO: maybe split these?
    </span><span class="doccomment">/// Argument of a complex number.
    </span>Arg,
    <span class="doccomment">/// Real part of a complex number.
    </span>Re,
    <span class="doccomment">/// Imaginary part of a complex number.
    </span>Im,
    <span class="doccomment">/// Complex conjugate.
    </span>Conj,
    <span class="doccomment">/// Returns true if x is an integer - that is, it is real and has no fractional part.
    </span>IsInt,
    <span class="doccomment">/// Returns true when n is exactly 0.
    </span>IsZero,
    <span class="attribute">#[serde(alias = <span class="string">&quot;sqr&quot;</span>)]
    </span><span class="doccomment">/// Square root of a number.
    </span>Sqrt,
    <span class="doccomment">/// nth root of x
    </span>Root,
    <span class="doccomment">/// Natural Logarithm
    </span>Ln,
    <span class="doccomment">/// Logarithm with base b, or base 10 if b is not given.
    </span>Log,
    <span class="doccomment">/// Convert radians to degrees.
    </span>Degrees,
    <span class="doccomment">/// Convert degrees to radians.
    </span>Radians,
    <span class="doccomment">/// Sign of a number, 1 if positive, -1 if negative and 0 when 0.
    </span><span class="attribute">#[serde(alias = <span class="string">&quot;sgn&quot;</span>)]
    </span>Sign,
    <span class="doccomment">/// Greatest of the given numbers.
    </span>Max,
    <span class="doccomment">/// Least of the given numbers.
    </span>Min,
    <span class="doccomment">/// Return the point nearest to x in the interval [a,b].
    /// Equivalent to max(a,min(x,b)).
    </span>Clamp,
    <span class="doccomment">/// Round n to d decimal places. On matrices and vectors, this rounds each element independently.
    </span>PrecRound,
    <span class="doccomment">/// Round n to f significant figures. On matrices and vectors, this rounds each element independently.
    </span>SigRound,
    <span class="doccomment">/// Returns true if b−t&lt;=a&lt;=b+t
    </span>WithIntolerance,
    <span class="doccomment">/// Round n to d decimal places and return a string, padding with zeros if necessary.
    /// If style is given, the number is rendered using the given notation style. See the page on Number notation for more on notation styles.
    </span>DPFormat,
    <span class="doccomment">/// Assuming n is a string representing a number, return the number of decimal places used. The string is passed through cleannumber() first.
    </span>CountDP,
    <span class="doccomment">/// Round n to d significant figures and return a string, padding with zeros if necessary.
    </span>SigFormat,
    <span class="doccomment">/// Assuming n is a string representing a number, return the number of significant figures. The string is passed through cleannumber() first.
    </span>CountSigFigs,
    <span class="doccomment">/// Returns true if str is a string representing a number given to the desired number of decimal places or significant figures.
    /// precisionType is either &quot;dp&quot;, for decimal places, or &quot;sigfig&quot;, for significant figures.
    /// If strict is true, then trailing zeroes must be included.
    </span>ToGivenPrecision,
    <span class="doccomment">/// Round a to the nearest multiple of b.
    </span>ToNearest,
    <span class="doccomment">/// Render the number n using the given number notation style.
    /// See the page on Number notation for more on notation styles.
    </span>FormatNumber,
    <span class="doccomment">/// Return a LaTeX string representing the given number in scientific notation, a×10^b.
    /// This function exists because scientific notation may use superscripts, which aren’t easily typeset in plain text.
    </span>ScientificNumberLaTeX,
    <span class="doccomment">/// Return an HTML element representing the given number in scientific notation, a×10^b.
    /// This function exists because scientific notation may use superscripts, which aren’t easily typeset in plain text.
    </span>ScientificNumberHTML,
    <span class="doccomment">/// Clean a string potentially representing a number. Remove space, and then try to identify a notation style, and rewrite to the plain-en style.
    /// styles is a list of notation styles. If styles is given, str will be tested against the given styles. If it matches, the string will be rewritten using the matched integer and decimal parts, with punctuation removed and the decimal point changed to a dot.
    </span>CleanNumber,
    <span class="doccomment">/// Try to match a string representing a number in any of the given styles at the start of the given string, and return both the matched text and a corresponding number value.
    </span>MatchNumber,
    <span class="doccomment">/// Parse a string representing a number written in the given style.
    /// If a list of styles is given, the first that accepts the given string is used.
    /// See the page on Number notation for more on notation styles.
    </span>ParseNumber,
    <span class="attribute">#[serde(rename = <span class="string">&quot;parsenumber_or_fraction&quot;</span>)]
    </span><span class="doccomment">/// Works the same as parsenumber(), but also accepts strings of the form number/number, which it interprets as fractions.
    </span>ParseNumberOrFraction,
    <span class="doccomment">/// Parse a string representing a number written in the given style, and return a decimal value.
    /// If a list of styles is given, the first that accepts the given string is used.
    /// See the page on Number notation for more on notation styles.
    </span>ParseDecimal,
    <span class="attribute">#[serde(rename = <span class="string">&quot;parsedecimal_or_fraction&quot;</span>)]
    </span><span class="doccomment">/// Works the same as parsedecimal(), but also accepts strings of the form number/number, which it interprets as fractions.
    </span>ParseDecimalOrFraction,
    <span class="doccomment">/// Write the given number in binary: base 2.
    </span>ToBinary,
    <span class="doccomment">/// Write the given number in octal: base 8.
    </span>ToOctal,
    <span class="doccomment">/// Write the given number in hexadecimal: base 16.
    </span>ToHexadecimal,
    <span class="doccomment">/// Write the given number in the given base. base can be any integer between 2 and 36.
    </span>ToBase,
    <span class="doccomment">/// Convert a string representing a number written in binary (base 2) to a integer value.
    </span>FromBinary,
    <span class="doccomment">/// Convert a string representing a number written in octal (base 8) to a integer value.
    </span>FromOctal,
    <span class="doccomment">/// Convert a string representing a number written in hexadecimal (base 16) to a integer value.
    </span>FromHexadecimal,
    <span class="doccomment">/// Convert a string representing a number written in the given base to a integer value. base can be any integer between 2 and 36.
    </span>FromBase,
    <span class="doccomment">/// Is n the “not a number” value, NaN?
    </span>IsNan,

    <span class="doccomment">/// Sine
    </span>Sin,
    <span class="doccomment">/// Cosine
    </span>Cos,
    <span class="doccomment">/// Tangent: tan(x) = sin(x)/cos(x)
    </span>Tan,
    <span class="doccomment">/// Cosecant: = 1 / sin(x)
    </span>Cosec,
    <span class="doccomment">/// Secant: = 1 / cos(x)
    </span>Sec,
    <span class="doccomment">/// Cotangent: = 1 / tan(x)
    </span>Cot,
    <span class="doccomment">/// Inverse of sin
    </span>ArcSin,
    <span class="doccomment">/// Inverse of cos
    </span>ArcCos,
    <span class="doccomment">/// Inverse of tan
    </span>ArcTan,
    <span class="doccomment">/// The angle in radians between the positive x-axis and the line through the origin and (x,y). This is often equivalent to arctan(y/x), except when x&lt;0, when pi is either added or subtracted from the result.
    </span>ATan2,
    <span class="doccomment">/// Hyperbolic sine
    </span>Sinh,
    <span class="doccomment">/// Hyperbolic cosine
    </span>Cosh,
    <span class="doccomment">/// Hyperbolic tangent
    </span>Tanh,
    <span class="doccomment">/// Hyperbolic cosecant
    </span>Cosech,
    <span class="doccomment">/// Hyperbolic secant
    </span>Sech,
    <span class="doccomment">/// Hyperbolic cotangent
    </span>Coth,
    <span class="doccomment">/// Inverse of sinh
    </span>ArcSinh,
    <span class="doccomment">/// Inverse of cosh
    </span>ArcCosh,
    <span class="doccomment">/// Inverse of tanh
    </span>ArcTanh,

    <span class="doccomment">/// fact(x) is a synonym for x!.
    </span>Fact,
    <span class="doccomment">/// Factorise n. Returns the exponents of the prime factorisation of n as a list.
    </span>Factorise,
    <span class="doccomment">/// Returns the divisors of n as a list: positive integers d such that d || n.
    </span>Divisors,
    <span class="attribute">#[serde(rename = <span class="string">&quot;proper_divisors&quot;</span>)]
    </span><span class="doccomment">/// Returns the proper divisors of n as a list: positive integers d &lt; n such that d || n.
    /// That is, the divisors of n, excluding n itself.
    </span>ProperDivisors,
    <span class="doccomment">/// Gamma function
    </span>Gamma,
    <span class="doccomment">/// Round up to the nearest integer. When x is complex, each component is rounded separately.
    </span>Ceil,
    <span class="doccomment">/// Round down to the nearest integer. When x is complex, each component is rounded separately.
    </span>Floor,
    <span class="doccomment">/// Round to the nearest integer. 0.5 is rounded up.
    </span>Round,
    <span class="doccomment">/// If x is positive, round down to the nearest integer; if it is negative, round up to the nearest integer.
    </span>Trunc,
    <span class="doccomment">/// Fractional part of a number. Equivalent to x-trunc(x).
    </span>Fract,
    <span class="attribute">#[serde(rename = <span class="string">&quot;rational_approximation&quot;</span>)]
    </span><span class="doccomment">/// Compute a rational approximation to the given number by computing terms of its continued fraction, returning the numerator and denominator separately. The approximation will be within e−accuracy of the true value; the default value for accuracy is 15.
    </span>RationalApproximation,
    <span class="doccomment">/// Modulo; remainder after integral division, i.e. a mod b.
    </span>Mod,
    <span class="doccomment">/// Count permutations
    </span>Perm,
    <span class="doccomment">/// Count combinations
    </span>Comb,
    <span class="attribute">#[serde(alias = <span class="string">&quot;gcf&quot;</span>)]
    </span><span class="doccomment">/// Greatest common divisor of integers a and b
    </span>GCD,
    <span class="attribute">#[serde(rename = <span class="string">&quot;gcd_without_pi_or_i&quot;</span>)]
    </span><span class="doccomment">/// Take out factors of π or i from a and b before computing their greatest common denominator.
    </span>GCDWithoutPIorI,
    <span class="doccomment">/// Are a and b coprime? True if their gcd() is 1, or if either of a or b is not an integer.
    </span>CoPrime,
    <span class="doccomment">/// Lowest common multiple of integers a and b. Can be used with any number of arguments; it returns the lowest common multiple of all the arguments.
    </span>LCM,

    <span class="doccomment">/// Create a vector with given components. Alternately, you can create a vector from a single list of numbers.
    </span>Vector,
    <span class="doccomment">/// Create a matrix with given rows, which should be either vectors or lists of numbers. Or, you can pass in a single list of lists of numbers.
    </span>Matrix,
    <span class="doccomment">/// Identity matrix with n rows and columns.
    </span>Id,
    <span class="doccomment">/// The number of rows in the given matrix
    </span>NumRows,
    <span class="doccomment">/// The number of columns in the given matrix
    </span>NumColumns,
    <span class="doccomment">/// Create a row vector (1×n matrix) with the given components. Alternately, you can create a row vector from a single list of numbers.
    </span>RowVector,
    <span class="doccomment">/// Dot (scalar) product. Inputs can be vectors or column matrices.
    </span>Dot,
    <span class="doccomment">/// Cross product. Inputs can be vectors or column matrices.
    </span>Cross,
    <span class="doccomment">/// Angle between vectors a and b, in radians. Returns 0 if either a or b has length 0.
    </span>Angle,
    <span class="attribute">#[serde(rename = <span class="string">&quot;is_zero&quot;</span>)]
    </span><span class="doccomment">/// Returns true if every component of the vector x is zero.
    </span>IsZeroVector,
    <span class="attribute">#[serde(rename = <span class="string">&quot;is_scalar_multiple&quot;</span>)]
    </span><span class="doccomment">/// Returns true if u is a scalar multiple of v. That is, if u = k*v for some real number k.
    /// The optional arguments rel_tol and abs_tol specify the relative and absolute tolerance of
    /// the equality check for each component; see isclose.
    </span>IsScalarMultiple,
    <span class="doccomment">/// Determinant of a matrix. Throws an error if used on anything larger than a 3×3 matrix.
    </span>Det, <span class="comment">// Why not for larger matrices?
    </span><span class="doccomment">/// Matrix transpose.
    </span>Transpose,
    <span class="doccomment">/// Calculate the sum of all the cells in a matrix.
    </span><span class="attribute">#[serde(rename = <span class="string">&quot;sum_cells&quot;</span>)]
    </span>SumCells,
    <span class="attribute">#[serde(alias = <span class="string">&quot;combine_horizontally&quot;</span>)]
    </span><span class="doccomment">/// Combine two matrices horizontally: given r1 x c1 a matrix m1 and a r2 x c2 matrix m2, returns a new max(1, r2) x (c1 + c2) matrix formed by putting the two matrices side, and padding with zeros where necessary.
    </span>Augment,
    <span class="attribute">#[serde(alias = <span class="string">&quot;combine_vertically&quot;</span>)]
    </span><span class="doccomment">/// Combine two matrices vertically: given a r1 x c1 matrix m1 and a r2 x c2 matrix m2, returns a new (r1 + r2) x max(c1, c2) matrix formed by putting m1 above m2, and padding with zeros where necessary.
    </span>Stack,
    <span class="attribute">#[serde(rename = <span class="string">&quot;combine_diagonally&quot;</span>)]
    </span><span class="doccomment">/// Combine two matrices diagonally: given a r1 x c1 matrix m1 and a r2 x c2 matrix m2, returns a new (r1 + r2) x (c1 + c2) matrix whose top-left quadrant is m1 and bottom-right quadrant is m2.
    </span>CombineDiagonally,

    <span class="doccomment">/// Convert x to a string.
    /// When converting a expression value to a string, you can give a list of display options as a second argument, either as a comma-separated string or a list of strings.
    </span>String,
    <span class="doccomment">/// Mark string x as containing raw LaTeX, so when it’s included in a mathmode environment it doesn’t get wrapped in a \textrm environment.
    /// If x is a expression value, it’s rendered to LaTeX.
    /// Note that backslashes must be double up, because the backslash is an escape character in JME strings.
    </span>LaTeX,
    <span class="doccomment">/// Mark string x as safe: don’t substitute variable values into it when this expression is evaluated.
    /// Use this function to preserve curly braces in string literals.
    </span>Safe,
    <span class="doccomment">/// Substitute variable values into the string x, even if it’s marked as safe (see safe()).
    /// The optional dictionary values overrides any previously-defined values of variables.
    /// Note: The variable dependency checker can’t establish which variables will be used in the string until render is evaluated, so you may encounter errors if using render in the definition of a question variable. You can ensure a variable has been evaluated by including it in the values argument, e.g.:
    /// render(&quot;a is {}&quot;,[&quot;a&quot;: a])
    /// This function is intended for use primarily in content areas.
    </span>Render,
    <span class="doccomment">/// Capitalise the first letter of a string.
    </span>Capitalise,
    <span class="doccomment">/// Return singular if n is 1, otherwise return plural.
    </span>Pluralise,
    <span class="doccomment">/// Convert string to upper-case.
    </span>Upper,
    <span class="doccomment">/// Convert string to lower-case.
    </span>Lower,
    <span class="doccomment">/// Join a list of strings with the given delimiter.
    </span>Join,
    <span class="doccomment">/// Split a string at every occurrence of delimiter, returning a list of the resulting pieces.
    </span>Split,
    <span class="attribute">#[serde(rename = <span class="string">&quot;match_regex&quot;</span>)]
    </span><span class="doccomment">/// If str matches the regular expression pattern, returns a list of matched groups, otherwise returns an empty list.
    /// This function uses JavaScript regular expression syntax.
    /// flags is an optional string listing the options flags to use. If it’s not given, the default value of &quot;u&quot; is used.
    </span>MatchRegex,
    <span class="attribute">#[serde(rename = <span class="string">&quot;split_regex&quot;</span>)]
    </span><span class="doccomment">/// Split a string at every occurrence of a substring matching the given regular expression pattern, returning a list of the the remaining pieces.
    /// flags is an optional string listing the options flags to use. If it’s not given, the default value of &quot;u&quot; is used.
    </span>SplitRegex,
    <span class="attribute">#[serde(rename = <span class="string">&quot;replace_regex&quot;</span>)]
    </span><span class="doccomment">/// Replace a substring of string matching the given regular expression pattern with the string replacement.
    /// flags is an optional string listing the options flags to use. If it’s not given, the default value of &quot;u&quot; is used.
    /// Remember that backslashes must be doubled up inside JME strings, and curly braces are normally used to substitute in variables. You can use the safe() function to avoid this behaviour.
    /// To replace all occurrences of the pattern, add the flag &quot;g&quot;.
    </span>ReplaceRegex,
    <span class="doccomment">/// Remove whitespace from the start and end of str.
    </span>Trim,
    <span class="doccomment">/// Write a currency amount, with the given prefix or suffix characters.
    </span>Currency,
    <span class="attribute">#[serde(rename = <span class="string">&quot;separateThousands&quot;</span>)]
    </span><span class="doccomment">/// Write a number, with the given separator character between every 3 digits
    /// To write a number using notation appropriate to a particular culture or context, see formatnumber().
    </span>SeparateThousands,
    <span class="doccomment">/// Get rid of the % on the end of a percentage and parse as a number, then divide by 100.
    </span>UnPercent,
    <span class="doccomment">/// Add copies of prefix to the start of str until the result is at least n characters long.
    </span>LPad,
    <span class="doccomment">/// Add copies of suffix to the end of str until the result is at least n characters long.
    </span>RPad,
    <span class="doccomment">/// For each occurrence of %s in str, replace it with the corresponding entry in the list values.
    </span>FormatString,
    <span class="doccomment">/// Get the n^th element of the sequence a, b, c, ..., aa, ab, ....
    /// Note that the numbering starts from 0.
    </span>LetterOrdinal,
    <span class="doccomment">/// Translate the given string, if it’s in the localisation file.
    /// Look at the default localisation file for strings which can be translated. This function takes a key representing a string to be translated, and returns the corresponding value from the current localisation file.
    /// arguments is a dictionary of named substitutions to make in the string.
    </span>Translate,
    <span class="doccomment">/// After converting to lower case, is str any of the strings &quot;true&quot;, &quot;false&quot;, &quot;yes&quot; or &quot;no&quot;?
    </span>IsBool,

    <span class="doccomment">/// Returns true if x is close to y.
    /// The arguments rel_tol and abs_tol are optional, with default values of 10−15.
    /// Equivalent to the following expression:
    </span>IsClose,
    <span class="doccomment">/// Returns true if a and b are both of the same data type, and “close enough” according to the given checking function.
    /// Vectors, matrices, and lists are considered equal only if every pair of corresponding elements in a and b is “close enough”.
    /// checkingFunction is the name of a checking function to use. These are documented in the Numbas runtime documentation.
    </span>ResultsEqual,

    <span class="doccomment">/// Evaluate expression n times, and return the results in a list.
    </span>Repeat,
    <span class="doccomment">/// Returns true if every element of list is true.
    </span>All,
    <span class="doccomment">/// Returns true if at least one element of list is true.
    </span><span class="prelude-val">Some</span>,
    <span class="doccomment">/// Evaluate expression for each item in list, range, vector or matrix d, replacing variable name with the element from d each time.
    /// You can also give a list of names if each element of d is a list of values. The Nth element of the list will be mapped to the Nth name.
    </span>Map,
    <span class="doccomment">/// Filter each item in list or range d, replacing variable name with the element from d each time, returning only the elements for which expression evaluates to true.
    </span>Filter,
    <span class="doccomment">/// Accumulate a value by iterating over a collection. This can be used as an abstraction of routines such as “sum of a list of numbers”, or “maximum value in a list”.
    /// Evaluate expression for each item in the list, range, vector or matrix d, accumulating a single value which is returned.
    /// At each iteration, the variable item_name is replaced with the corresponding value from d. The variable accumulator_name is replaced with first_value for the first iteration, and the result of expression from the previous iteration subsequently.
    </span>FoldL,
    <span class="doccomment">/// Iterate an expression on the given initial value the given number of times, returning a list containing the values produced at each step.
    /// You can also give a list of names. The Nth element of the value will be mapped to the Nth name.
    </span>Iterate,
    <span class="doccomment">/// Iterate an expression on the given initial value until the condition is satisfied, returning a list containing the values produced at each step.
    /// You can also give a list of names. The Nth element of the value will be mapped to the Nth name.
    /// max_iterations is an optional parameter specifying the maximum number of iterations that may be performed. If not given, the default value of 100 is used. This parameter prevents the function from running indefinitely, when the condition is never met.
    </span><span class="attribute">#[serde(rename = <span class="string">&quot;iterate_until&quot;</span>)]
    </span>IterateUntil,
    <span class="doccomment">/// Take the first n elements from list or range d, replacing variable name with the element from d each time, returning only the elements for which expression evaluates to true.
    /// This operation is lazy - once n elements satisfying the expression have been found, execution stops. You can use this to filter a few elements from a large list, where the condition might take a long time to calculate.
    </span>Take,
    <span class="doccomment">/// “Flatten” a list of lists, returning a single list containing the concatenation of all the entries in lists.
    </span>Flatten,
    <span class="doccomment">/// Evaluate expression, temporarily defining variables with the given names. Use this to cut down on repetition. You can define any number of variables - in the first calling pattern, follow a variable name with its definition. Or you can give a dictionary mapping variable names to their values. The last argument is the expression to be evaluated.
    </span>Let,
    <span class="doccomment">/// Sort a list
    </span>Sort,
    <span class="doccomment">/// Return a list giving the index that each entry in the list will occupy after sorting.
    </span><span class="attribute">#[serde(rename = <span class="string">&quot;sort_destinations&quot;</span>)]
    </span>SortDestinations,
    <span class="doccomment">/// Sort the given list of either list or dict values by their entries corresponding to the given key. When sorting a list of lists, the key is a number representing the index of each list to look at. When sorting a list of dictionaries, the key is a string.
    </span><span class="attribute">#[serde(rename = <span class="string">&quot;sort_by&quot;</span>)]
    </span>SortBy,
    <span class="doccomment">/// Group the entries in the given list of either list or dict values by their entries corresponding to the given key. The returned value is a list of lists of the form [key, group], where key is the value all elements of the list group have in common.
    /// When grouping a list of lists, the key argument is a number representing the index of each list to look at. When grouping a list of dictionaries, the key argument is a string.
    </span><span class="attribute">#[serde(rename = <span class="string">&quot;group_by&quot;</span>)]
    </span>GroupBy,
    <span class="doccomment">/// Reverse list
    </span>Reverse,
    <span class="doccomment">/// Find the indices at which value occurs in list.
    </span>Indices,
    <span class="doccomment">/// Return a copy of the list x with duplicates removed.
    </span>Distinct,
    <span class="doccomment">/// Convert a value to a list of its components (or rows, for a matrix).
    </span>List,
    <span class="doccomment">/// Evaluate a dictionary of variable definitions and return a dictionary containing the generated values.
    /// definitions is a dictionary mapping variable names to expression values corresponding to definitions.
    /// The definitions can refer to other variables to be evaluated, or variables already defined in the current scope. Variables named in the dictionary which have already been defined will be removed before evaluation begins.
    </span><span class="attribute">#[serde(rename = <span class="string">&quot;make_variables&quot;</span>)]
    </span>MakeVariables,
    <span class="doccomment">/// Each variable name in names should have a corresponding definition expression in
    /// definitions. conditions is a list of expressions which you want to evaluate to true.
    /// The definitions will be evaluated repeatedly until all the conditions are satisfied, or
    /// the number of attempts is greater than maxRuns. If maxRuns isn’t given, it defaults to
    /// 100 attempts.
    </span>Satisfy,
    <span class="doccomment">/// Add up a list of numbers
    </span>Sum,
    <span class="doccomment">/// Multiply a list of numbers together
    </span>Prod,
    <span class="doccomment">/// Cartesian product of lists. In other words, every possible combination of choices of one value from each given list.
    /// If one list and a number are given, then the n-th Cartesian power of the list is returned: the Cartesian product of n copies of the list.
    </span>Product,
    <span class="doccomment">/// Combine two (or more) lists into one - the Nth element of the output is a list containing the Nth elements of each of the input lists.
    </span>Zip,
    <span class="doccomment">/// All ordered choices of r elements from collection, without replacement.
    </span>Combinations,
    <span class="doccomment">/// All ordered choices of r elements from collection, with replacement.
    </span><span class="attribute">#[serde(rename = <span class="string">&quot;combinations_with_replacement&quot;</span>)]
    </span>CombinationsWithReplacement,
    <span class="doccomment">/// All choices of r elements from collection, in any order, without replacement.
    </span>Permutations,
    <span class="doccomment">/// Count the number of times each distinct element of collection appears.
    /// Returns a list of pairs [value, frequency], where value is a value from the list, and frequency is the number of times it appeared.
    </span>Frequencies,
    <span class="doccomment">/// Enumerate the elements of collection: this function returns a list containing, for each element v of collection, a new list of the form [i,v], where i is the index of the element in collection.
    </span>Enumerate,

    <span class="doccomment">/// Get the value corresponding to the given key string in the dictionary.
    /// If the key is not present in the dictionary, the default value will be returned.
    </span>Get,
    <span class="doccomment">/// Create a dictionary with the given key-value pairs. Equivalent to [ .. ], except when no key-value pairs are given: [] creates an empty list instead.
    /// You can alternately pass a list of pairs of the form [key, value], to transform a list into a dictionary.
    </span>Dict,
    <span class="doccomment">/// A list of all of the given dictionary’s keys.
    </span>Keys,
    <span class="doccomment">/// A list of the values corresponding to each of the given dictionary’s keys.
    /// If a list of keys is given, only the values corresponding to those keys are returned, in the same order.
    </span>Values,
    <span class="doccomment">/// A list of all of the [key,value] pairs in the given dictionary.
    </span>Items,

    <span class="doccomment">/// Create a set with the given elements. Either pass the elements as individual arguments, or as a list.
    </span>Set,
    <span class="doccomment">/// Union of sets a and b
    </span>Union,
    <span class="doccomment">/// Intersection of sets a and b, i.e. elements which are in both sets.
    </span>Intersection,

    <span class="doccomment">/// Pick uniformly at random from a range, list, or from the given arguments.
    </span>Random,
    <span class="doccomment">/// Pick random from a weighted list of items. Each element in the input list is a pair of the form [item, probability], where probability is a number value.
    /// Items with negative weight are ignored.
    </span><span class="attribute">#[serde(rename = <span class="string">&quot;weighted_random&quot;</span>)]
    </span>WeightedRandom,
    <span class="doccomment">/// Get a random shuffling of the integers [0…n−1]
    </span>Deal,
    <span class="doccomment">/// Reorder a list given a permutation. The i&#39;th element of the output is the order[i]&#39;th element of list.
    </span>Reorder,
    <span class="doccomment">/// Random shuffling of list or range.
    </span>Shuffle,
    <span class="doccomment">/// Shuffle several lists together - each list has the same permutation of its elements applied. The lists must all be the same length, otherwise an error is thrown.
    </span><span class="attribute">#[serde(rename = <span class="string">&quot;shuffle_together&quot;</span>)]
    </span>ShuffleTogether,

    <span class="doccomment">/// Return a if b is true, else return 0.
    </span>Award,
    <span class="doccomment">/// If p is true, return a, else return b. Only the returned value is evaluated.
    </span>If,
    <span class="doccomment">/// Select cases. Alternating boolean expressions with values to return, with the final argument representing the default case. Only the returned value is evaluated.
    </span>Switch,
    <span class="doccomment">/// If condition is false, then return value, otherwise don’t evaluate value and return false. This is intended for use in marking scripts, to apply marking feedback only if a condition is met.
    </span>Assert,
    <span class="doccomment">/// Try to evaluate expression. If it is successfully evaluated, return the result. Otherwise,
    /// evaluate except, with the error message available as name.
    </span>Try,

    <span class="doccomment">/// Parse string x as HTML.
    </span>HTML,
    <span class="doccomment">/// Does str represent a string of HTML containing text? Returns false for the empty string, or HTML elements with no text content.
    </span>IsNonEmptyHTML,
    <span class="doccomment">/// Create an HTML with cell contents defined by data, which should be a list of lists of data,
    /// and column headers defined by the list of strings headers.
    </span>Table,
    <span class="doccomment">/// Create an HTML img element loading the image from the given URL. Images uploaded through the resources tab are stored in the relative URL resources/images/&lt;filename&gt;.png, where &lt;filename&gt; is the name of the original file.
    </span>Image,
    <span class="doccomment">/// Apply a CSS max-width attribute to the given element. You can use this to ensure that an
    /// image is not displayed too wide. The given width is in pixels.
    </span><span class="attribute">#[serde(rename = <span class="string">&quot;max_width&quot;</span>)]
    </span>MaxWidth,
    <span class="doccomment">/// Apply a CSS max-height attribute to the given element. You can use this to ensure that an image is not displayed too long. The given height is in pixels.
    </span><span class="attribute">#[serde(rename = <span class="string">&quot;max_height&quot;</span>)]
    </span>MaxHeight,

    <span class="doccomment">/// Decode a JSON string into JME data types.
    /// JSON is decoded into numbers, strings, booleans, lists, or dictionaries. To produce other data types, such as matrices or vectors, you will have to post-process the resulting data.
    /// Warning: The JSON value null is silently converted to an empty string, because JME has no “null” data type. This may change in the future.
    </span><span class="attribute">#[serde(rename = <span class="string">&quot;json_decode&quot;</span>)]
    </span>JsonDecode,
    <span class="doccomment">/// Convert the given object to a JSON string.
    /// Numbers, strings, booleans, lists, and dictionaries are converted in a straightforward manner. Other data types may behave unexpectedly.
    </span><span class="attribute">#[serde(rename = <span class="string">&quot;json_encode&quot;</span>)]
    </span>JsonEncode,

    <span class="doccomment">/// Parse a string as a JME expression. The expression can be substituted into other expressions, such as the answer to a mathematical expression part, or the \simplify LaTeX command.
    /// Warning: Note that the argument to expression is evaluated using the same rules as any
    /// other JME expression, so for example expression(&quot;2&quot; + &quot;x&quot;) is equivalent to
    /// expression(&quot;2x&quot;), not expression(&quot;2 + x&quot;). A good way to construct a randomised
    /// sub-expression is using substitute().
    </span><span class="attribute">#[serde(alias = <span class="string">&quot;expression&quot;</span>)]
    </span>Parse,
    <span class="doccomment">/// Evaluate the given sub-expression.
    /// If values is given, it should be a dictionary mapping names of variables to their values.
    </span>Eval,
    <span class="doccomment">/// Returns the arguments of the top-level operation of expression, as a list of sub-expressions. If expression is a data type other than an operation or function, an empty list is returned.
    /// Binary operations only ever have two arguments. For example, 1+2+3 is parsed as (1+2)+3.
    </span>Args,
    <span class="doccomment">/// Returns the name of the data type of the top token in the expression, as a string.
    </span>Type,
    <span class="doccomment">/// Construct a name token with the given name.
    </span>Name,
    <span class="doccomment">/// Construct an operator with the given name.
    </span>Op,
    <span class="doccomment">/// Construct a function token with the given name.
    </span>Function,
    <span class="doccomment">/// Returns a sub-expression representing the application of the given operation to the list of arguments.
    </span>Exec,
    <span class="doccomment">/// Return a list of all unbound variables used in the given expression. Effectively, this is all the variables that need to be given values in order for this expression to be evaluated.
    /// Bound variables are those defined as part of operations which also assign values to those variables, such as map or let.
    </span>FindVars,
    <span class="doccomment">/// Substitute the given variable values into expression.
    /// variables is a dictionary mapping variable names to values.
    </span>Substitute,
    <span class="doccomment">/// Apply the given simplification rules to expression, until no rules apply.
    /// rules is a list of names of rules to apply, given either as a string containing a comma-separated list of names, or a list of strings.
    /// Unlike the \\simplify command in content areas, the basic rule is not turned on by default.
    /// See Substituting variables into displayed maths for a list of rules available.
    </span>Simplify,
    <span class="doccomment">/// Expand juxtapositions in variable and function names for implicit multiplication of terms or composition of functions. This is to do with strings of letters with no spaces or operator symbols between them.
    /// options is an optional dictionary of settings for the process. It can contain the following keys.
    ///     singleLetterVariables - Insist that all variable names consist of a single letter, interpreting longer strings of characters as implicit multiplication. Greek letters are considered to be one letter long.
    ///     noUnknownFunctions - When a name appears before a bracket, but it’s not the name of a defined function, interpret it as a multiplication instead. This does not apply function applications with more than one argument.
    /// implicitFunctionComposition - When several function names are juxtaposed together to form a string that is not the name of a defined function, or several function names are joined with the multiplication symbol *, interpret it as implicity composition of functions.
    /// If options is not given, all of these are turned on.
    /// Variable name annotations, subscripts and primes do not count towards the number of letters in a name.
    </span><span class="attribute">#[serde(rename = <span class="string">&quot;expand_juxtapositions&quot;</span>)]
    </span>ExpandJuxtapositions,
    <span class="doccomment">/// Compare expressions a and b using the “canonical” ordering. Returns -1 if a should go before b, 0 if they are considered “equal”, and 1 if a should go after b.
    /// Expressions are examined in the following order:
    ///     Names used: all variable names used in each expression are collected in a depth-first search and the resulting lists are compared lexicographically.
    ///     Data type: if a and b are of different data types, op and function go first, and then they are compared using the names of their data types.
    ///     Polynomials: terms of the form x^b or a*x^b, where a and b are numbers and x is a variable name, go before anything else.
    ///     Function name: if a and b are both function applications, they are compared using the names of the functions. If the functions are the same, the arguments are compared. Powers, or multiples of powers, go after anything else.
    ///     Number: if a and b are both numbers, the lowest number goes first. Complex numbers are compared by real part and then by imaginary part.
    ///     Elements of other data types are considered to be equal to any other value of the same data type.
    </span><span class="attribute">#[serde(rename = <span class="string">&quot;canonical_compare&quot;</span>)]
    </span>CanonicalCompare,
    <span class="doccomment">/// Compare expression a and b by substituting random values in for the free variables.
    /// Returns true if a and b have exactly the same free variables, and produce the same results when evaluated against the randomly chosen values.
    /// For more control over the evaluation, see resultsequal().
    </span><span class="attribute">#[serde(rename = <span class="string">&quot;numerical_compare&quot;</span>)]
    </span>NumericalCompare,
    <span class="doccomment">/// Set the case-sensitivity of the scope and then evaluate expression.
    /// If case_sensitive is not given, it defaults to true.
    /// Case-sensitivity affects variable and function names. The names x and X are considered equivalent when not in case-sensitive mode, but are considered to be different when in case-sensitive mode.
    </span><span class="attribute">#[serde(rename = <span class="string">&quot;scope_case_sensitive&quot;</span>)]
    </span>ScopeCaseSensitive,

    <span class="doccomment">/// Differentiate the given expression with respect to the given variable name
    </span>Diff,

    <span class="doccomment">/// If expr matches pattern, return a dictionary of the form [&quot;match&quot;: boolean, &quot;groups&quot;: dict], where &quot;groups&quot; is a dictionary mapping names of matches to sub-expressions.
    /// See the documentation on pattern-matching mathematical expressions.
    /// If you don’t need to use any parts of the matched expression, use matches() instead.
    </span>Match,
    <span class="doccomment">/// Return true if expr matches pattern.
    /// Use this if you’re not interested in capturing any parts of the matched expression.
    </span>Matches,
    <span class="doccomment">/// Replace occurrences of pattern in expr with the expression created by substituting the matched items into replacement.
    </span>Replace,

    <span class="doccomment">/// Attempt to infer the types of free variables in the given expression.
    /// There can be more than one valid assignment of types to the variables in an expression. For example, in the expression a+a, the variable a can be any type which has a defined addition operation.
    /// Returns the first possible assignment of types to variables, as a dictionary mapping variable names to the name of its type. If a variable name is missing from the dictionary, the algorithm can’t establish any constraint on it.
    </span><span class="attribute">#[serde(rename = <span class="string">&quot;infer_variable_types&quot;</span>)]
    </span>InferVariableTypes,
    <span class="doccomment">/// Attempt to infer the type of the value produced by the given expression, which may contain free variables.
    /// First, the types of any free variables are inferred. Then, definitions of an operations or functions in the function are chosen to match the types of their arguments.
    /// Returns the name of the expression’s output type as a string, or &quot;?&quot; if the type can’t be determined.
    </span><span class="attribute">#[serde(rename = <span class="string">&quot;infer_type&quot;</span>)]
    </span>InferType,

    <span class="doccomment">/// Returns a list containing the names of every variable defined in the current scope, as strings.
    </span>DefinedVariables,
    <span class="doccomment">/// Returns true if the variable with the given name has been defined in the current scope.
    </span>IsSet,
    <span class="doccomment">/// Temporarily remove the named variables, functions and rulesets from the scope, and evaluate the given expression.
    </span>Unset,
}

<span class="kw">impl </span>BuiltinFunctions {
    <span class="kw">pub fn </span>get(s: <span class="kw-2">&amp;</span>str) -&gt; <span class="prelude-ty">Option</span>&lt;<span class="self">Self</span>&gt; {
        serde_plain::from_str(s).ok()
    }
}
</code></pre></div>
</section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="numbas" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.66.0-nightly (1898c34e9 2022-10-26)" ></div></body></html>